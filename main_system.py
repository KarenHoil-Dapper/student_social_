import pandas as pd
import numpy as np
import joblib
import os
from datetime import datetime
import json
import warnings
warnings.filterwarnings('ignore')

class SocialMediaHealthPredictor:
    """Sistema completo para encuestas, predicciones y actualizaci√≥n de modelos"""
    
    def __init__(self, model_path="model_advanced", data_file="Social_Bueno.xlsx"):
        self.model_path = model_path
        self.data_file = data_file
        self.models = {}
        self.selectors = {}
        self.features = {}
        self.model_info = {}
        self.load_models()
        
    def load_models(self):
        """Carga todos los modelos entrenados"""
        try:
            # Cargar informaci√≥n del modelo
            if os.path.exists(f"{self.model_path}/model_info.pkl"):
                self.model_info = joblib.load(f"{self.model_path}/model_info.pkl")
                print("üìã Informaci√≥n del modelo cargada")
            
            # Cargar modelos de clustering
            if os.path.exists(f"{self.model_path}/kmeans_advanced.pkl"):
                self.models['clustering'] = joblib.load(f"{self.model_path}/kmeans_advanced.pkl")
                self.models['scaler'] = joblib.load(f"{self.model_path}/scaler_advanced.pkl")
                print("‚úÖ Modelo de clustering cargado")
            
            # Cargar modelos de regresi√≥n
            if os.path.exists(f"{self.model_path}/regression_best.pkl"):
                self.models['regression'] = joblib.load(f"{self.model_path}/regression_best.pkl")
                self.selectors['regression'] = joblib.load(f"{self.model_path}/regression_selector.pkl")
                self.features['regression'] = joblib.load(f"{self.model_path}/regression_features.pkl")
                print("‚úÖ Modelo de regresi√≥n cargado")
            
            # Cargar modelos de clasificaci√≥n
            if os.path.exists(f"{self.model_path}/classification_best.pkl"):
                self.models['classification'] = joblib.load(f"{self.model_path}/classification_best.pkl")
                self.selectors['classification'] = joblib.load(f"{self.model_path}/classification_selector.pkl")
                self.features['classification'] = joblib.load(f"{self.model_path}/classification_features.pkl")
                print("‚úÖ Modelo de clasificaci√≥n cargado")
                
        except Exception as e:
            print(f"‚ö†Ô∏è Error cargando modelos: {e}")
            print("üí° Aseg√∫rate de entrenar los modelos primero ejecutando el script de entrenamiento")
    
    def create_survey_questions(self):
        """Define las preguntas de la encuesta adaptadas a tu dataset"""
        questions = {
            'informacion_personal': {
                'Age': "¬øCu√°l es tu edad?",
                'Gender': "¬øCu√°l es tu g√©nero? (0=Femenino, 1=Masculino, 2=Otro)"
            },
            'uso_redes_sociales': {
                'Avg_Daily_Usage_Hours': "¬øCu√°ntas horas al d√≠a usas redes sociales en promedio?",
                'Sleep_Hours_Per_Night': "¬øCu√°ntas horas duermes por noche normalmente?",
                'Conflicts_Over_Social_Media': "¬øHas tenido conflictos por el uso de redes sociales? (0=Nunca, 1=Rara vez, 2=A veces, 3=Frecuentemente, 4=Siempre)",
                'Addicted_Score': "En una escala del 1 al 10, ¬øqu√© tan adicto te consideras a las redes sociales?"
            },
            'nivel_academico': {
                'academic_level': "¬øCu√°l es tu nivel acad√©mico? (1=Secundaria, 2=Universitario, 3=Posgrado)"
            },
            'plataforma_principal': {
                'main_platform': """¬øCu√°l es tu plataforma principal? 
                1=Facebook, 2=Instagram, 3=TikTok, 4=YouTube, 5=WhatsApp, 
                6=Twitter, 7=Snapchat, 8=LinkedIn, 9=Otra"""
            },
            'estado_relacion': {
                'relationship_status': "¬øCu√°l es tu estado de relaci√≥n? (1=Soltero, 2=En relaci√≥n, 3=Es complicado)"
            }
        }
        return questions
    
    def conduct_survey(self):
        """Realiza la encuesta interactiva"""
        print("üéØ ENCUESTA DE SALUD MENTAL Y REDES SOCIALES")
        print("="*50)
        print("Por favor responde las siguientes preguntas honestamente.")
        print("Tus datos ser√°n utilizados para mejorar nuestro sistema de predicci√≥n.\n")
        
        questions = self.create_survey_questions()
        responses = {}
        
        for category, category_questions in questions.items():
            print(f"\nüìã {category.replace('_', ' ').title()}")
            print("-" * 30)
            
            for key, question in category_questions.items():
                while True:
                    try:
                        response = float(input(f"{question}: "))
                        responses[key] = response
                        break
                    except ValueError:
                        print("‚ùå Por favor ingresa un valor num√©rico v√°lido.")
        
        # Agregar timestamp
        responses['survey_date'] = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        responses['survey_id'] = f"survey_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        
        return responses
    
    def prepare_features_for_model(self, responses):
        """Convierte las respuestas en el formato que espera el modelo"""
        # Crear un registro completo con todas las columnas del dataset
        new_record = {}
        
        # Generar nuevo Student_ID
        try:
            df_existing = pd.read_excel(self.data_file)
            max_id = df_existing['Student_ID'].max() if 'Student_ID' in df_existing.columns else 0
            new_record['Student_ID'] = max_id + 1
        except:
            new_record['Student_ID'] = 1
        
        # Informaci√≥n b√°sica
        new_record['Age'] = responses.get('Age', 20)
        new_record['Gender'] = int(responses.get('Gender', 1))
        new_record['Avg_Daily_Usage_Hours'] = responses.get('Avg_Daily_Usage_Hours', 3)
        new_record['Sleep_Hours_Per_Night'] = responses.get('Sleep_Hours_Per_Night', 7)
        new_record['Conflicts_Over_Social_Media'] = int(responses.get('Conflicts_Over_Social_Media', 0))
        new_record['Addicted_Score'] = responses.get('Addicted_Score', 5)
        
        # Nivel acad√©mico (one-hot encoding)
        academic_level = int(responses.get('academic_level', 2))
        new_record['Academic_Level_High School'] = 1 if academic_level == 1 else 0
        new_record['Academic_Level_Undergraduate'] = 1 if academic_level == 2 else 0
        new_record['Academic_Level_Graduate'] = 1 if academic_level == 3 else 0
        
        # Plataforma principal (one-hot encoding)
        platform_mapping = {
            1: 'Most_Used_Platform_Facebook',
            2: 'Most_Used_Platform_Instagram', 
            3: 'Most_Used_Platform_TikTok',
            4: 'Most_Used_Platform_YouTube',
            5: 'Most_Used_Platform_WhatsApp',
            6: 'Most_Used_Platform_Twitter',
            7: 'Most_Used_Platform_Snapchat',
            8: 'Most_Used_Platform_LinkedIn'
        }
        
        # Inicializar todas las plataformas a 0
        platforms = ['Facebook', 'Instagram', 'KakaoTalk', 'LINE', 'LinkedIn', 
                    'Snapchat', 'TikTok', 'Twitter', 'VKontakte', 'WeChat', 
                    'WhatsApp', 'YouTube']
        for platform in platforms:
            new_record[f'Most_Used_Platform_{platform}'] = 0
        
        # Activar la plataforma seleccionada
        main_platform = int(responses.get('main_platform', 4))
        if main_platform in platform_mapping:
            new_record[platform_mapping[main_platform]] = 1
        else:
            new_record['Most_Used_Platform_YouTube'] = 1  # Default
        
        # Estado de relaci√≥n (one-hot encoding)
        relationship = int(responses.get('relationship_status', 1))
        new_record['Relationship_Status_Single'] = 1 if relationship == 1 else 0
        new_record['Relationship_Status_In Relationship'] = 1 if relationship == 2 else 0
        new_record['Relationship_Status_Complicated'] = 1 if relationship == 3 else 0
        
        # Inicializar todas las columnas de pa√≠ses a 0 (asumimos ubicaci√≥n desconocida)
        countries = ['Afghanistan', 'Albania', 'Andorra', 'Argentina', 'Armenia', 'Australia', 
                    'Austria', 'Azerbaijan', 'Bahamas', 'Bahrain', 'Bangladesh', 'Belarus', 
                    'Belgium', 'Bhutan', 'Bolivia', 'Bosnia', 'Brazil', 'Bulgaria', 'Canada', 
                    'Chile', 'China', 'Colombia', 'Costa Rica', 'Croatia', 'Cyprus', 
                    'Czech Republic', 'Denmark', 'Ecuador', 'Egypt', 'Estonia', 'Finland', 
                    'France', 'Georgia', 'Germany', 'Ghana', 'Greece', 'Hong Kong', 'Hungary', 
                    'Iceland', 'India', 'Indonesia', 'Iraq', 'Ireland', 'Israel', 'Italy', 
                    'Jamaica', 'Japan', 'Jordan', 'Kazakhstan', 'Kenya', 'Kosovo', 'Kuwait', 
                    'Kyrgyzstan', 'Latvia', 'Lebanon', 'Liechtenstein', 'Lithuania', 
                    'Luxembourg', 'Malaysia', 'Maldives', 'Malta', 'Mexico', 'Moldova', 
                    'Monaco', 'Montenegro', 'Morocco', 'Nepal', 'Netherlands', 'New Zealand', 
                    'Nigeria', 'North Macedonia', 'Norway', 'Oman', 'Pakistan', 'Panama', 
                    'Paraguay', 'Peru', 'Philippines', 'Poland', 'Portugal', 'Qatar', 
                    'Romania', 'Russia', 'San Marino', 'Serbia', 'Singapore', 'Slovakia', 
                    'Slovenia', 'South Africa', 'South Korea', 'Spain', 'Sri Lanka', 'Sweden', 
                    'Switzerland', 'Syria', 'Taiwan', 'Tajikistan', 'Thailand', 'Trinidad', 
                    'Turkey', 'UAE', 'UK', 'USA', 'Ukraine', 'Uruguay', 'Uzbekistan', 
                    'Vatican City', 'Venezuela', 'Vietnam', 'Yemen']
        
        for country in countries:
            new_record[f'Country_{country}'] = 0
        
        # Valores por defecto para columnas target (ser√°n predichas)
        new_record['Mental_Health_Score'] = None  # Se predicir√°
        new_record['Affects_Academic_Performance'] = None  # Se predicir√°
        
        # Agregar metadatos
        new_record['survey_date'] = responses.get('survey_date')
        new_record['survey_id'] = responses.get('survey_id')
        
        return new_record
    
    def make_predictions(self, prepared_data):
        """Realiza predicciones usando los modelos entrenados"""
        predictions = {}
        
        try:
            # Preparar caracter√≠sticas para el modelo
            if 'extended_features' in self.model_info:
                available_features = []
                feature_values = []
                
                for feature in self.model_info['extended_features']:
                    if feature in prepared_data and prepared_data[feature] is not None:
                        available_features.append(feature)
                        feature_values.append(prepared_data[feature])
                    else:
                        # Usar valor por defecto si la caracter√≠stica no est√° disponible
                        available_features.append(feature)
                        feature_values.append(0)  # Valor por defecto
                
                X = pd.DataFrame([feature_values], columns=available_features)
                
                # Clustering
                if 'clustering' in self.models and 'scaler' in self.models:
                    X_scaled = self.models['scaler'].transform(X)
                    cluster = self.models['clustering'].predict(X_scaled)[0]
                    predictions['cluster'] = int(cluster)
                
                # Regresi√≥n (Mental Health Score)
                if 'regression' in self.models and 'regression' in self.selectors:
                    X_reg_selected = self.selectors['regression'].transform(X)
                    
                    model_name, model, poly_features = self.models['regression']
                    if poly_features is not None:  # Modelo polinomial
                        X_reg_selected = poly_features.transform(X_reg_selected)
                    
                    mental_health_score = model.predict(X_reg_selected)[0]
                    predictions['mental_health_score'] = float(mental_health_score)
                
                # Clasificaci√≥n (Academic Performance Impact)
                if 'classification' in self.models and 'classification' in self.selectors:
                    X_clf_selected = self.selectors['classification'].transform(X)
                    
                    model_name, model = self.models['classification']
                    academic_impact = model.predict(X_clf_selected)[0]
                    academic_impact_proba = model.predict_proba(X_clf_selected)[0]
                    
                    predictions['affects_academic_performance'] = int(academic_impact)
                    predictions['academic_impact_probability'] = float(max(academic_impact_proba))
            
        except Exception as e:
            print(f"‚ö†Ô∏è Error en predicciones: {e}")
            predictions['error'] = str(e)
        
        return predictions
    
    def generate_recommendations(self, prepared_data, predictions):
        """Genera recomendaciones personalizadas basadas en predicciones"""
        recommendations = []
        
        # Basado en horas de uso
        usage_hours = prepared_data.get('Avg_Daily_Usage_Hours', 0)
        if usage_hours > 6:
            recommendations.append("üö® Tu uso de redes sociales es muy alto (>6h/d√≠a). Considera establecer l√≠mites de tiempo.")
        elif usage_hours > 4:
            recommendations.append("‚ö†Ô∏è Tu uso de redes sociales es considerable. Intenta reducir gradualmente el tiempo.")
        else:
            recommendations.append("‚úÖ Tu uso de redes sociales parece estar en un rango saludable.")
        
        # Basado en sue√±o
        sleep_hours = prepared_data.get('Sleep_Hours_Per_Night', 7)
        if sleep_hours < 7:
            recommendations.append("üò¥ Necesitas m√°s horas de sue√±o. Intenta dormir al menos 7-8 horas por noche.")
        elif sleep_hours > 9:
            recommendations.append("üò¥ Duermes m√°s de lo normal. Considera revisar tu rutina de sue√±o.")
        
        # Basado en predicci√≥n de salud mental
        if 'mental_health_score' in predictions:
            score = predictions['mental_health_score']
            if score < 4:
                recommendations.append("üÜò Tu puntuaci√≥n de salud mental es preocupante. Considera buscar ayuda profesional.")
            elif score < 6:
                recommendations.append("‚ö†Ô∏è Tu salud mental podr√≠a necesitar atenci√≥n. Practica t√©cnicas de mindfulness.")
            elif score >= 8:
                recommendations.append("üòä ¬°Excelente salud mental! Mant√©n tus h√°bitos actuales.")
            else:
                recommendations.append("üòä Tu salud mental est√° en buen estado. Sigue cuid√°ndote.")
        
        # Basado en impacto acad√©mico
        if 'affects_academic_performance' in predictions and predictions['affects_academic_performance'] == 1:
            recommendations.append("üìö Las redes sociales podr√≠an estar afectando tu rendimiento acad√©mico. Considera usar apps de bloqueo durante estudio.")
        
        # Basado en puntuaci√≥n de adicci√≥n
        addiction_score = prepared_data.get('Addicted_Score', 5)
        if addiction_score >= 8:
            recommendations.append("‚ö†Ô∏è Tu puntuaci√≥n de adicci√≥n es alta. Considera t√©cnicas de desintoxicaci√≥n digital.")
        
        # Basado en conflictos
        conflicts = prepared_data.get('Conflicts_Over_Social_Media', 0)
        if conflicts >= 3:
            recommendations.append("üí¨ Los conflictos por redes sociales son frecuentes. Practica comunicaci√≥n digital saludable.")
        
        return recommendations
    
    def save_survey_data(self, prepared_data, predictions, recommendations):
        """Guarda los datos de la encuesta en el archivo Excel"""
        try:
            # Agregar predicciones a los datos preparados
            final_data = prepared_data.copy()
            
            if 'mental_health_score' in predictions:
                final_data['Mental_Health_Score'] = predictions['mental_health_score']
            if 'affects_academic_performance' in predictions:
                final_data['Affects_Academic_Performance'] = predictions['affects_academic_performance']
            
            # Cargar datos existentes
            if os.path.exists(self.data_file):
                existing_df = pd.read_excel(self.data_file)
                
                # Asegurar que el nuevo registro tenga todas las columnas
                for col in existing_df.columns:
                    if col not in final_data:
                        final_data[col] = 0  # Valor por defecto
                
                # Crear DataFrame con el nuevo registro
                new_row_df = pd.DataFrame([final_data])
                
                # Reordenar columnas para que coincidan
                new_row_df = new_row_df.reindex(columns=existing_df.columns, fill_value=0)
                
                # Concatenar con datos existentes
                updated_df = pd.concat([existing_df, new_row_df], ignore_index=True)
            else:
                updated_df = pd.DataFrame([final_data])
            
            # Guardar archivo actualizado
            updated_df.to_excel(self.data_file, index=False)
            print(f"‚úÖ Datos guardados en {self.data_file}")
            
            # Guardar tambi√©n un log detallado
            log_data = {
                'timestamp': datetime.now().isoformat(),
                'prepared_data': {k: v for k, v in prepared_data.items() if v is not None},
                'predictions': predictions,
                'recommendations': recommendations
            }
            
            log_file = f"survey_log_{datetime.now().strftime('%Y%m')}.json"
            
            # Cargar log existente o crear nuevo
            if os.path.exists(log_file):
                with open(log_file, 'r', encoding='utf-8') as f:
                    existing_log = json.load(f)
                existing_log.append(log_data)
            else:
                existing_log = [log_data]
            
            # Guardar log actualizado
            with open(log_file, 'w', encoding='utf-8') as f:
                json.dump(existing_log, f, indent=2, ensure_ascii=False)
            
            return True
            
        except Exception as e:
            print(f"‚ùå Error guardando datos: {e}")
            import traceback
            traceback.print_exc()
            return False
    
    def display_results(self, prepared_data, predictions, recommendations):
        """Muestra los resultados al usuario de forma amigable"""
        print("\n" + "="*60)
        print("üéØ RESULTADOS DE TU EVALUACI√ìN")
        print("="*60)
        
        # Informaci√≥n b√°sica
        print(f"\nüìä RESUMEN DE TUS DATOS:")
        print(f"   üë§ Edad: {prepared_data.get('Age', 'N/A')} a√±os")
        print(f"   üíª Uso diario de redes sociales: {prepared_data.get('Avg_Daily_Usage_Hours', 'N/A')} horas")
        print(f"   üò¥ Horas de sue√±o: {prepared_data.get('Sleep_Hours_Per_Night', 'N/A')} horas")
        print(f"   üì± Puntuaci√≥n de adicci√≥n: {prepared_data.get('Addicted_Score', 'N/A')}/10")
        
        # Predicciones
        print(f"\nüîÆ PREDICCIONES DEL MODELO:")
        if 'mental_health_score' in predictions:
            score = predictions['mental_health_score']
            print(f"   üß† Puntuaci√≥n de Salud Mental: {score:.2f}/10")
            if score >= 8:
                print("      ‚úÖ Excelente salud mental")
            elif score >= 6:
                print("      üòä Buena salud mental")
            elif score >= 4:
                print("      ‚ö†Ô∏è Salud mental regular - considera mejoras")
            else:
                print("      üö® Salud mental preocupante - busca ayuda")
        
        if 'affects_academic_performance' in predictions:
            impact = predictions['affects_academic_performance']
            probability = predictions.get('academic_impact_probability', 0)
            if impact == 1:
                print(f"   üìö Impacto Acad√©mico: S√ç afecta ({probability*100:.1f}% probabilidad)")
            else:
                print(f"   üìö Impacto Acad√©mico: NO afecta significativamente ({probability*100:.1f}% probabilidad)")
        
        if 'cluster' in predictions:
            cluster = predictions['cluster']
            print(f"   üë• Perfil de Usuario: Grupo {cluster}")
        
        # Recomendaciones
        print(f"\nüí° RECOMENDACIONES PERSONALIZADAS:")
        if recommendations:
            for i, rec in enumerate(recommendations, 1):
                print(f"   {i}. {rec}")
        else:
            print("   ‚úÖ ¬°Felicidades! Pareces tener h√°bitos saludables con las redes sociales.")
        
        # Informaci√≥n adicional
        print(f"\nüìà INFORMACI√ìN ADICIONAL:")
        print(f"   üïí Evaluaci√≥n realizada: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        print(f"   üîÑ Tus datos ayudar√°n a mejorar el modelo para futuras evaluaciones")
        print(f"   üÜî ID de encuesta: {prepared_data.get('survey_id', 'N/A')}")
        
        print("\n" + "="*60)
        print("¬°Gracias por participar en nuestra evaluaci√≥n!")
        print("="*60)
    
    def run_survey_session(self):
        """Ejecuta una sesi√≥n completa de encuesta"""
        try:
            print("üöÄ Iniciando sistema de evaluaci√≥n de salud mental y redes sociales...\n")
            
            # Verificar que los modelos est√©n cargados
            if not self.models:
                print("‚ùå No se pudieron cargar los modelos.")
                print("üí° Primero necesitas entrenar los modelos:")
                print("   python main_system.py --train")
                return
            
            # Realizar encuesta
            responses = self.conduct_survey()
            
            # Preparar datos para el modelo
            prepared_data = self.prepare_features_for_model(responses)
            
            # Hacer predicciones
            print("\nüîÑ Analizando tus respuestas...")
            predictions = self.make_predictions(prepared_data)
            
            # Generar recomendaciones
            recommendations = self.generate_recommendations(prepared_data, predictions)
            
            # Mostrar resultados
            self.display_results(prepared_data, predictions, recommendations)

            # Guardar datos
            if self.save_survey_data(prepared_data, predictions, recommendations):
                print("\n‚úÖ Tus datos han sido guardados para mejorar el sistema.")
                print(f"üìä Total de registros en el dataset: {len(pd.read_excel(self.data_file))}")
            
            # Preguntar si quiere otra evaluaci√≥n
            while True:
                another = input("\n¬øQuieres realizar otra evaluaci√≥n? (s/n): ").strip().lower()
                if another in ['s', 'si', 's√≠', 'y', 'yes']:
                    print("\n" + "="*60)
                    self.run_survey_session()
                    break
                elif another in ['n', 'no']:
                    print("\n¬°Gracias por usar nuestro sistema! üéâ")
                    break
                else:
                    print("‚ùå Por favor responde 's' para s√≠ o 'n' para no.")
            
        except KeyboardInterrupt:
            print("\n\nüëã Sesi√≥n cancelada por el usuario. ¬°Hasta pronto!")
        except Exception as e:
            print(f"\n‚ùå Error durante la sesi√≥n: {e}")
            import traceback
            traceback.print_exc()

def main():
    """Funci√≥n principal"""git 
    print("üéØ SISTEMA DE EVALUACI√ìN DE SALUD MENTAL Y REDES SOCIALES")
    print("="*60)
    print("Este sistema utiliza inteligencia artificial para evaluar el impacto")
    print("de las redes sociales en tu salud mental y rendimiento acad√©mico.")
    print("="*60)
    
    # Crear instancia del predictor
    predictor = SocialMediaHealthPredictor()
    
    # Ejecutar sesi√≥n de encuesta
    predictor.run_survey_session()

if __name__ == "__main__":
    main()